# Module Federation Architecture

### 1. マイクロフロントエンドの境界線 (The Cut Line)

バックエンドのマイクロサービスは「データと機能（ドメイン）」で切りましたが、フロントエンドは**「ユーザー体験（UX）とチーム編成」**で切るのが一般的です。

もし Module Federation で分割するなら、以下の **3つのアプリ（Remotes）** と **1つの親（Host/Shell）** に分けるのが最も綺麗です。

#### 構成図 (Module Federation Architecture)

* **Host (App Shell):**
* **役割:** 全体の「枠」を提供する親アプリ。
* **責務:** ログイン判定、グローバルナビゲーション、ルーティングの制御。
* *「客なのか？嬢なのか？」を判定し、適切なマイクロフロントエンドを読み込む。*


* **Remote A: User App (Gentleman App):**
* **対象:** 一般ユーザー（客）。
* **範囲:** ホーム(検索)、チャット(客側)、履歴、プロフィール閲覧。
* **理由:** 「没入感」や「探索」が重視されるため、独自のUI/UXフローが必要。


* **Remote B: Cast App (Goddess App):**
* **対象:** キャスト（嬢）。
* **範囲:** ダッシュボード、チャット(嬢側)、マイページ、設定ウィザード。
* **理由:** 「管理画面」に近い性質があり、PCやタブレットでの利用も想定される。ユーザー側とはデザインの方向性も異なる。


* **Remote C: Design System (Shared Lib):**
* **対象:** 共通。
* **範囲:** ボタン、アイコン、カラーパレット、フォント定義。
* **理由:** ここを共有しないと、User App と Cast App で「ボタンの黄色」が微妙に違う…といったブランド崩壊が起きるため。



---

### 2. Module Federation の役割

ここで **Module Federation** がどう機能するかというと、**「実行時（Runtime）の合体ロボ」** を実現するために使われます。

* **ビルドの独立性:**
* 「Cast App」チームが新しい機能をデプロイしても、「User App」チームはビルドし直す必要がありません。


* **動的な読み込み:**
* ユーザーがログインして「自分はキャストだ」と分かった瞬間、ブラウザは `remoteEntry.js` (Cast Appの入口) だけをダウンロードします。User Appの巨大なコードは読み込まれません。



**「バックエンドとの違い」のポイント:**
バックエンドでは「チャット機能」だけを切り出しましたが、フロントエンドで「チャット画面だけ」を別アプリ（MFE）として切り出すと、**画面遷移した瞬間に一瞬カクついたり、CSSが崩れたりするリスク**が高まります。
そのため、機能単位ではなく**「アプリケーション（ユーザー層）単位」**で大きく切るのが定石です。

---

### 3. 具体例

もしこれを実装すると、リポジトリ構成はこうなります。

```text
/xxxxx-monorepo
  ├── /apps
  │    ├── /shell       (Next.js: http://xxxxx.com)
  │    ├── /user-app    (Next.js: 検索・予約・客チャット)
  │    └── /cast-app    (Next.js: 管理・CRM・嬢チャット)
  └── /packages
       └── /ui-library  (React Components: ボタン・カード・配色)

```

**シナリオ:**

1. **URL:** `xxxxx.com/cast/dashboard` にアクセス。
2. **Shell:** URLを見て「これは Cast App だな」と判断。
3. **Module Federation:** サーバー（またはCDN）から `cast-app` の最新バンドルを取得して、Shellの中にある `<div id="root">` に展開。
4. **画面表示:** キャスト用ダッシュボードが表示される。

---

### 4. 結論：やるべきか？ (Reality Check)

**思考実験としての答え:**
はい、分割するなら **「User App」と「Cast App」という2つの巨大なモジュール** に分け、それらを **「Shell」** が統合する形になります。

**現実的なアドバイス:**
今の規模であれば、Module Federation（実行時統合）は**早すぎます**。
代わりに **「Monorepo (Turborepo / Nx)」** を使い、**ビルド時統合** にするのがベストプラクティスです。

* **Monorepo:** コードは分かれているが、デプロイ時は1つのNext.jsアプリとしてビルドされる。
* **メリット:** 型安全性（TypeScript）が維持しやすい、デプロイが楽、動作が高速。
* **デメリット:** 全体のビルド時間が少し長くなる。

今の「Next.js App Router」自体が、すでにディレクトリごとに分割されているようなものなので、あえてMFEの複雑さを持ち込む必要はありません。
「将来、キャスト用アプリの開発チームが50人、ユーザー用アプリの開発チームが50人になったら」検討するタイミングです！
