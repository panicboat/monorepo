version: '3.8'

services:
  # User Service & Database
  user-service:
    build:
      context: ./services/user-service
      dockerfile: Dockerfile
    ports:
      - "50051:50051"
    networks:
      - app-network
    depends_on:
      user-postgres:
        condition: service_healthy
    environment:
      - DB_HOST=user-postgres
      - DB_PORT=5432
      - DB_USER=user_admin
      - DB_PASSWORD=user_password
      - DB_NAME=user_db
      - TZ=Asia/Tokyo
    restart: unless-stopped

  user-postgres:
    image: postgres:17-alpine
    networks:
      - app-network
    environment:
      - POSTGRES_DB=user_db
      - POSTGRES_USER=user_admin
      - POSTGRES_PASSWORD=user_password
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --locale=C
      - TZ=Asia/Tokyo
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U user_admin -d user_db"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    volumes:
      - user_postgres_data:/var/lib/postgresql/data
      - ./infrastructure/database/user/initdb.d:/docker-entrypoint-initdb.d
    restart: unless-stopped

  # Product Service & Database
  product-service:
    build:
      context: ./services/product-service
      dockerfile: Dockerfile
    ports:
      - "50052:50052"
    networks:
      - app-network
    depends_on:
      product-postgres:
        condition: service_healthy
    environment:
      - DB_HOST=product-postgres
      - DB_PORT=5432
      - DB_USER=product_admin
      - DB_PASSWORD=product_password
      - DB_NAME=product_db
      - TZ=Asia/Tokyo
    restart: unless-stopped

  product-postgres:
    image: postgres:17-alpine
    networks:
      - app-network
    environment:
      - POSTGRES_DB=product_db
      - POSTGRES_USER=product_admin
      - POSTGRES_PASSWORD=product_password
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --locale=C
      - TZ=Asia/Tokyo
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U product_admin -d product_db"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    volumes:
      - product_postgres_data:/var/lib/postgresql/data
      - ./infrastructure/database/product/initdb.d:/docker-entrypoint-initdb.d
    restart: unless-stopped

  # Order Service & Database
  order-service:
    build:
      context: ./services/order-service
      dockerfile: Dockerfile
    ports:
      - "50053:50053"
    networks:
      - app-network
    depends_on:
      order-postgres:
        condition: service_healthy
    environment:
      - DB_HOST=order-postgres
      - DB_PORT=5432
      - DB_USER=order_admin
      - DB_PASSWORD=order_password
      - DB_NAME=order_db
      - TZ=Asia/Tokyo
    restart: unless-stopped

  order-postgres:
    image: postgres:17-alpine
    networks:
      - app-network
    environment:
      - POSTGRES_DB=order_db
      - POSTGRES_USER=order_admin
      - POSTGRES_PASSWORD=order_password
      - POSTGRES_INITDB_ARGS=--encoding=UTF-8 --locale=C
      - TZ=Asia/Tokyo
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U order_admin -d order_db"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    volumes:
      - order_postgres_data:/var/lib/postgresql/data
      - ./infrastructure/database/order/initdb.d:/docker-entrypoint-initdb.d
    restart: unless-stopped

  # gRPC Gateway
  api-gateway:
    build:
      context: ./services/api-gateway
      dockerfile: Dockerfile
    ports:
      - "8080:8080"
    networks:
      - app-network
    depends_on:
      - user-service
      - product-service
      - order-service
    environment:
      - USER_SERVICE_ADDRESS=user-service:50051
      - PRODUCT_SERVICE_ADDRESS=product-service:50052
      - ORDER_SERVICE_ADDRESS=order-service:50053
      - TZ=Asia/Tokyo
    restart: unless-stopped

  # Frontend Services
  frontend-shell:
    build:
      context: ./apps/web/shell
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    networks:
      - app-network
    environment:
      - NODE_ENV=development
      - REACT_APP_API_URL=http://localhost:8080
    volumes:
      - ./apps/web/shell:/app
      - /app/node_modules
    command: npm run dev

  frontend-user:
    build:
      context: ./apps/web/user-portal
      dockerfile: Dockerfile
    ports:
      - "3001:3001"
    networks:
      - app-network
    environment:
      - NODE_ENV=development
      - REACT_APP_API_URL=http://localhost:8080
    volumes:
      - ./apps/web/user-portal:/app
      - /app/node_modules
    command: npm run dev

  frontend-product:
    build:
      context: ./apps/web/product-catalog
      dockerfile: Dockerfile
    ports:
      - "3002:3002"
    networks:
      - app-network
    environment:
      - NODE_ENV=development
      - REACT_APP_API_URL=http://localhost:8080
    volumes:
      - ./apps/web/product-catalog:/app
      - /app/node_modules
    command: npm run dev

  frontend-order:
    build:
      context: ./apps/web/order-management
      dockerfile: Dockerfile
    ports:
      - "3003:3003"
    networks:
      - app-network
    environment:
      - NODE_ENV=development
      - REACT_APP_API_URL=http://localhost:8080
    volumes:
      - ./apps/web/order-management:/app
      - /app/node_modules
    command: npm run dev

  # Reverse Proxy (Docker Compose環境専用)
  # 注意: Kubernetes環境では ingress-nginx を使用するため不要
  reverse-proxy:
    build:
      context: ./infrastructure/nginx/reverse-proxy
      dockerfile: Dockerfile
    ports:
      - "80:80"
    networks:
      - app-network
    depends_on:
      - api-gateway
      - frontend-shell
      - frontend-user
      - frontend-product
      - frontend-order
    restart: unless-stopped

networks:
  app-network:
    driver: bridge

volumes:
  user_postgres_data:
  product_postgres_data:
  order_postgres_data: