#!/usr/bin/env ruby

require 'grpc'
require 'pg'
require 'dotenv/load'
require 'time'

# Product entity
class Product
  attr_accessor :id, :name, :description, :price, :stock, :created_at

  def initialize(id: nil, name: nil, description: nil, price: nil, stock: nil, created_at: nil)
    @id = id
    @name = name
    @description = description
    @price = price
    @stock = stock
    @created_at = created_at
  end

  def to_proto
    {
      id: @id,
      name: @name,
      description: @description,
      price: @price,
      stock: @stock,
      created_at: @created_at&.to_time
    }
  end
end

# Product service implementation
class ProductService
  def initialize(db_connection)
    @db = db_connection
  end

  def get_product(get_product_request)
    id = get_product_request.id
    
    result = @db.exec_params(
      'SELECT id, name, description, price, stock, created_at FROM products WHERE id = $1',
      [id]
    )
    
    if result.ntuples.zero?
      raise GRPC::NotFound.new("Product not found")
    end
    
    row = result[0]
    product = Product.new(
      id: row['id'].to_i,
      name: row['name'],
      description: row['description'],
      price: row['price'].to_f,
      stock: row['stock'].to_i,
      created_at: Time.parse(row['created_at'])
    )
    
    { product: product.to_proto }
  end

  def list_products(list_products_request)
    page_size = list_products_request.page_size
    page_size = 10 if page_size.nil? || page_size.zero?
    
    offset = 0
    unless list_products_request.page_token.nil? || list_products_request.page_token.empty?
      offset = list_products_request.page_token.to_i
    end
    
    result = @db.exec_params(
      'SELECT id, name, description, price, stock, created_at FROM products ORDER BY id LIMIT $1 OFFSET $2',
      [page_size + 1, offset]
    )
    
    products = []
    result.each do |row|
      product = Product.new(
        id: row['id'].to_i,
        name: row['name'],
        description: row['description'],
        price: row['price'].to_f,
        stock: row['stock'].to_i,
        created_at: Time.parse(row['created_at'])
      )
      products << product.to_proto
    end
    
    next_page_token = ""
    if products.length > page_size
      products = products[0...page_size]
      next_page_token = (offset + page_size).to_s
    end
    
    {
      products: products,
      next_page_token: next_page_token
    }
  end
end

# Simple gRPC server implementation
class ProductServiceServer
  attr_reader :port

  def initialize(port: 50052)
    @port = port
    @server = GRPC::RpcServer.new
    
    # Database connection
    db_host = ENV['DB_HOST'] || 'localhost'
    db_port = ENV['DB_PORT'] || '5432'
    db_user = ENV['DB_USER'] || 'product_admin'
    db_password = ENV['DB_PASSWORD'] || 'product_password'
    db_name = ENV['DB_NAME'] || 'product_db'
    
    @db = PG.connect(
      host: db_host,
      port: db_port,
      user: db_user,
      password: db_password,
      dbname: db_name
    )
    
    puts "Connected to database successfully"
    
    @product_service = ProductService.new(@db)
  end

  def start
    @server.add_http2_port("0.0.0.0:#{@port}", :this_port_is_insecure)
    
    # Register service handlers
    @server.handle(ProductServiceHandler.new(@product_service))
    
    puts "Product service listening on :#{@port}"
    @server.run_till_terminated_or_interrupted([1, 'int', 'SIGTERM'])
  end
end

# Product service handler for gRPC
class ProductServiceHandler
  def initialize(product_service)
    @product_service = product_service
  end

  def get_product(get_product_request, _unused_call)
    @product_service.get_product(get_product_request)
  end

  def list_products(list_products_request, _unused_call)
    @product_service.list_products(list_products_request)
  end
end

# Mock request classes (normally generated by protoc)
class GetProductRequest
  attr_accessor :id

  def initialize(id: nil)
    @id = id
  end
end

class ListProductsRequest
  attr_accessor :page_size, :page_token

  def initialize(page_size: nil, page_token: nil)
    @page_size = page_size
    @page_token = page_token
  end
end

# Start the server
if __FILE__ == $0
  begin
    server = ProductServiceServer.new
    server.start
  rescue => e
    puts "Error starting server: #{e.message}"
    puts e.backtrace
    exit 1
  end
end