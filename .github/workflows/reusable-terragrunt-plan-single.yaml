name: Reusable Terragrunt Plan (Single Environment)

on:
  workflow_call:
    inputs:
      project_name:
        description: 'Project name for the service'
        required: true
        type: string
      env_dir:
        description: 'Environment directory path'
        required: true
        type: string
      env_name:
        description: 'Environment name'
        required: true
        type: string
      service_dir:
        description: 'Service directory path'
        required: true
        type: string
      terraform_version:
        description: 'Terraform version'
        required: false
        type: string
        default: '1.5.7'
      terragrunt_version:
        description: 'Terragrunt version'
        required: false
        type: string
        default: '0.53.2'

permissions:
  id-token: write
  contents: read
  pull-requests: write

jobs:
  plan-single:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Load IAM role configuration
        id: load-config
        run: |
          CONFIG_FILE=".github/terragrunt-actions-config.yaml"
          ENV_NAME="${{ inputs.env_name }}"

          echo "environment-name=$ENV_NAME" >> $GITHUB_OUTPUT

          # Determine Plan IAM role: env.iam_role_plan â†’ default.iam_role_plan
          PLAN_IAM_ROLE=$(yq eval ".$ENV_NAME.iam_role_plan // .default.iam_role_plan" $CONFIG_FILE)
          AWS_REGION=$(yq eval ".$ENV_NAME.aws_region // .default.aws_region // \"us-east-1\"" $CONFIG_FILE)

          # Check for custom working directory
          WORKING_DIR=$(yq eval ".$ENV_NAME.working_directory" $CONFIG_FILE)
          if [ "$WORKING_DIR" != "null" ]; then
            FINAL_WORKING_DIR="$WORKING_DIR"
            echo "Using custom working directory from config: $WORKING_DIR"
          else
            FINAL_WORKING_DIR="${{ inputs.env_dir }}"
            echo "Using detected working directory: $FINAL_WORKING_DIR"
          fi

          # Check if we're using fallback
          SPECIFIC_PLAN_ROLE=$(yq eval ".$ENV_NAME.iam_role_plan" $CONFIG_FILE)
          if [ "$SPECIFIC_PLAN_ROLE" = "null" ]; then
            echo "Environment '$ENV_NAME' plan role not found, using default plan role"
          fi

          echo "plan-iam-role=$PLAN_IAM_ROLE" >> $GITHUB_OUTPUT
          echo "aws-region=$AWS_REGION" >> $GITHUB_OUTPUT
          echo "working-directory=$FINAL_WORKING_DIR" >> $GITHUB_OUTPUT
          echo "Using Plan IAM role: $PLAN_IAM_ROLE for environment: $ENV_NAME"

      - name: Configure AWS credentials for Plan
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ steps.load-config.outputs.plan-iam-role }}
          role-session-name: terragrunt-plan-${{ inputs.project_name }}-${{ inputs.env_name }}
          aws-region: ${{ steps.load-config.outputs.aws-region }}

      - name: Plan terragrunt for environment
        id: plan
        uses: gruntwork-io/terragrunt-action@v2
        with:
          tf_version: ${{ inputs.terraform_version }}
          tg_version: ${{ inputs.terragrunt_version }}
          tg_dir: ${{ steps.load-config.outputs.working-directory }}
          tg_command: 'plan --terragrunt-non-interactive --tf-forward-stdout'
        env:
          TF_INPUT: false
          AWS_DEFAULT_REGION: ${{ steps.load-config.outputs.aws-region }}
        continue-on-error: true

      - name: Plan terragrunt for environment (Alternative)
        id: plan-native
        if: steps.plan.outcome != 'success'
        run: |
          # Install Terragrunt if action failed
          TG_VERSION="${{ inputs.terragrunt_version }}"
          TF_VERSION="${{ inputs.terraform_version }}"

          # Install Terraform
          wget https://releases.hashicorp.com/terraform/${TF_VERSION}/terraform_${TF_VERSION}_linux_amd64.zip
          unzip terraform_${TF_VERSION}_linux_amd64.zip
          sudo mv terraform /usr/local/bin/

          # Install Terragrunt
          wget https://github.com/gruntwork-io/terragrunt/releases/download/v${TG_VERSION}/terragrunt_linux_amd64
          chmod +x terragrunt_linux_amd64
          sudo mv terragrunt_linux_amd64 /usr/local/bin/terragrunt

          # Run plan
          cd ${{ steps.load-config.outputs.working-directory }}
          terragrunt plan --terragrunt-non-interactive 2>&1 | tee plan_output.txt

          # Save output for parsing
          echo "PLAN_OUTPUT_FILE=plan_output.txt" >> $GITHUB_ENV
        env:
          TF_INPUT: false
          AWS_DEFAULT_REGION: ${{ steps.load-config.outputs.aws-region }}
        continue-on-error: true

      - name: Parse plan output (Alternative)
        id: parse-plan-alt
        if: steps.plan.outcome != 'success'
        run: |
          if [ -f "$PLAN_OUTPUT_FILE" ]; then
            PLAN_OUTPUT=$(cat "$PLAN_OUTPUT_FILE")
            echo "Using native command output"
          else
            PLAN_OUTPUT="No plan output available"
          fi

          # Rest of parsing logic same as above
          echo "=== Plan Output Debug (Native) ==="
          echo "Plan output length: ${#PLAN_OUTPUT}"
          echo "First 500 chars:"
          echo "${PLAN_OUTPUT:0:500}"

          # ... (parsing logic continues)
        run: |
          echo "=== Debugging Plan Outputs ==="
          echo "Plan outcome: ${{ steps.plan.outcome }}"
          echo "Plan outputs keys:"
          echo "${{ toJson(steps.plan.outputs) }}"
          echo ""
          echo "=== stdout length: ${#STDOUT} ==="
          STDOUT="${{ steps.plan.outputs.stdout }}"
          echo "First 1000 chars of stdout:"
          echo "${STDOUT:0:1000}"
          echo ""
          echo "=== stderr length: ${#STDERR} ==="
          STDERR="${{ steps.plan.outputs.stderr }}"
          echo "First 1000 chars of stderr:"
          echo "${STDERR:0:1000}"

      - name: Parse plan output
        id: parse-plan
        run: |
          # Try multiple sources for plan output
          PLAN_OUTPUT_STDOUT="${{ steps.plan.outputs.stdout }}"
          PLAN_OUTPUT_STDERR="${{ steps.plan.outputs.stderr }}"
          PLAN_OUTPUT_ACTION="${{ steps.plan.outputs.tg_action_output }}"

          # Use the most appropriate output source
          if [ ! -z "$PLAN_OUTPUT_ACTION" ]; then
            PLAN_OUTPUT="$PLAN_OUTPUT_ACTION"
            echo "Using tg_action_output for plan output"
          elif [ ! -z "$PLAN_OUTPUT_STDOUT" ]; then
            PLAN_OUTPUT="$PLAN_OUTPUT_STDOUT"
            echo "Using stdout for plan output"
          elif [ ! -z "$PLAN_OUTPUT_STDERR" ]; then
            PLAN_OUTPUT="$PLAN_OUTPUT_STDERR"
            echo "Using stderr for plan output"
          else
            PLAN_OUTPUT="No plan output available"
            echo "No plan output found in any source"
          fi

          echo "=== Plan Output Debug ==="
          echo "Plan output length: ${#PLAN_OUTPUT}"
          echo "First 500 chars:"
          echo "${PLAN_OUTPUT:0:500}"

          # Count changes - improved regex patterns
          if echo "$PLAN_OUTPUT" | grep -q "Plan:"; then
            # Extract the Plan line
            PLAN_LINE=$(echo "$PLAN_OUTPUT" | grep "Plan:" | tail -1)
            echo "Plan line found: $PLAN_LINE"

            # Extract numbers using improved patterns
            ADDITIONS=$(echo "$PLAN_LINE" | grep -o '[0-9]\+ to add' | grep -o '[0-9]\+' || echo "0")
            CHANGES=$(echo "$PLAN_LINE" | grep -o '[0-9]\+ to change' | grep -o '[0-9]\+' || echo "0")
            DELETIONS=$(echo "$PLAN_LINE" | grep -o '[0-9]\+ to destroy' | grep -o '[0-9]\+' || echo "0")
          else
            echo "No Plan line found in output"
            ADDITIONS="0"
            CHANGES="0"
            DELETIONS="0"
          fi

          PLAN_STATUS="${{ steps.plan.outcome }}"

          # Truncate output if too long
          TRUNCATED_OUTPUT=$(echo "$PLAN_OUTPUT" | head -c 30000)
          if [ ${#PLAN_OUTPUT} -gt 30000 ]; then
            TRUNCATED_OUTPUT="$TRUNCATED_OUTPUT\n\n... (output truncated, see workflow logs for full details)"
          fi

          # Escape special characters for GitHub
          ESCAPED_OUTPUT=$(echo "$TRUNCATED_OUTPUT" | sed 's/`/\\`/g' | sed 's/\$/\\$/g')

          echo "Extracted counts - Add: $ADDITIONS, Change: $CHANGES, Destroy: $DELETIONS"

          echo "additions=$ADDITIONS" >> $GITHUB_OUTPUT
          echo "changes=$CHANGES" >> $GITHUB_OUTPUT
          echo "deletions=$DELETIONS" >> $GITHUB_OUTPUT
          echo "status=$PLAN_STATUS" >> $GITHUB_OUTPUT
          echo "output<<EOF" >> $GITHUB_OUTPUT
          echo "$ESCAPED_OUTPUT" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Debug PR context
        run: |
          echo "Event name: ${{ github.event_name }}"
          echo "PR number: ${{ github.event.pull_request.number }}"
          echo "Base ref: ${{ github.base_ref }}"
          echo "Head ref: ${{ github.head_ref }}"

      - name: Find existing comment
        if: github.event_name == 'pull_request'
        uses: peter-evans/find-comment@v3
        id: find-comment
        with:
          issue-number: ${{ github.event.pull_request.number }}
          comment-author: 'github-actions[bot]'
          body-includes: 'terragrunt-plan-${{ inputs.env_name }}-${{ inputs.project_name }}'

      - name: Debug comment search
        if: github.event_name == 'pull_request'
        run: |
          echo "Comment ID found: ${{ steps.find-comment.outputs.comment-id }}"
          echo "Comment body includes: terragrunt-plan-${{ inputs.env_name }}-${{ inputs.project_name }}"

      - name: Create or update plan comment
        if: github.event_name == 'pull_request'
        uses: peter-evans/create-or-update-comment@v4
        with:
          comment-id: ${{ steps.find-comment.outputs.comment-id }}
          issue-number: ${{ github.event.pull_request.number }}
          body: |
            <!-- terragrunt-plan-${{ inputs.env_name }}-${{ inputs.project_name }} -->
            ## ğŸ“‹ Terragrunt Plan Results

            **Project**: ${{ inputs.project_name }}
            **Environment**: `${{ inputs.env_name }}`
            **Directory**: `${{ steps.load-config.outputs.working-directory }}`
            **IAM Role (Plan)**: ${{ steps.load-config.outputs.plan-iam-role }}
            **AWS Region**: ${{ steps.load-config.outputs.aws-region }}
            **Status**: ${{ steps.parse-plan.outputs.status == 'success' && 'âœ… Success' || 'âŒ Failed' }}

            ### ğŸ“Š Plan Summary

            | Action | Count |
            |--------|-------|
            | ğŸŸ¢ Add | ${{ steps.parse-plan.outputs.additions }} |
            | ğŸŸ¡ Change | ${{ steps.parse-plan.outputs.changes }} |
            | ğŸ”´ Destroy | ${{ steps.parse-plan.outputs.deletions }} |

            <details>
            <summary>ğŸ“ Plan Output</summary>

            ```hcl
            ${{ steps.parse-plan.outputs.output }}
            ```

            </details>

            <details>
            <summary>ğŸ“ Environment Structure</summary>

            ```
            ${{ inputs.service_dir }}/terragrunt/
            â”œâ”€â”€ root.hcl
            â”œâ”€â”€ Makefile
            â”œâ”€â”€ modules/
            â””â”€â”€ envs/
                â””â”€â”€ ${{ inputs.env_name }}/    â† This environment
            ```
            </details>

            Please review the plan output above before merging. View full logs: [${{ github.run_id }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

            *Last updated: ${{ steps.load-config.outputs.environment-name }} at ${{ github.event.pull_request.updated_at }}*
          edit-mode: replace
