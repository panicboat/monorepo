name: 'Auto Label - Label Dispatcher'

on:
  pull_request:
    types: [opened, synchronize]
    branches:
      - '**'

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  detect-and-label:
    name: 'Detect changes and update PR labels (Dynamic)'
    runs-on: ubuntu-latest
    steps:
      - name: Generate GitHub App token
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ vars.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ steps.app-token.outputs.token }}

      - name: Setup Python for configuration processing
        uses: actions/setup-python@v2
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Generate dynamic path filters from mappings.yaml
        id: generate-filters
        run: |
          python3 << 'EOF'
          import yaml
          import json
          import os
          import glob

          # Load configuration
          with open('.github/config/auto-label--mappings.yaml', 'r') as f:
              config = yaml.safe_load(f)

          # Discover existing services by scanning directories
          services = []
          for item in os.listdir('.'):
              if os.path.isdir(item) and not item.startswith('.'):
                  # Check if this directory contains terragrunt structure
                  terragrunt_path = os.path.join(item, 'terragrunt', 'envs')
                  if os.path.exists(terragrunt_path):
                      services.append(item)

          # Add special case services defined in config
          service_configs = {s['name']: s for s in config.get('services', [])}
          for service_name in service_configs.keys():
              if service_name not in services:
                  services.append(service_name)

          print(f"Discovered services: {services}")

          # Generate path filters and matrix
          filters = {}
          matrix_items = []

          for service in services:
              service_config = service_configs.get(service, {})
              conventions = service_config.get('directory_conventions', config['directory_conventions'])

              for env in config['environments']:
                  env_name = env['environment']

                  for stack, pattern in conventions.items():
                      path = pattern.format(service=service, environment=env_name)
                      filter_key = f"{service}-{env_name}-{stack}"

                      # Check if path actually exists
                      if os.path.exists(path):
                          filters[filter_key] = f"{path}/**"
                          matrix_items.append({
                              'service': service,
                              'environment': env_name,
                              'stack': stack,
                              'path': path,
                              'filter_key': filter_key
                          })
                          print(f"Added filter: {filter_key} -> {path}/**")
                      else:
                          print(f"Skipped non-existent path: {path}")

          # Set outputs
          matrix = {'include': matrix_items}

          # Create filters YAML string for dorny/paths-filter
          filters_yaml = ""
          if filters:
              for key, value in filters.items():
                  filters_yaml += f"{key}:\n  - '{value}'\n"
          else:
              filters_yaml = "_dummy:\n  - 'README.md'"

          # GitHub Actions output format
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f"matrix={json.dumps(matrix)}\n")
              f.write(f"has_filters={'true' if filters else 'false'}\n")
              f.write(f"filters_yaml<<EOF\n{filters_yaml}\nEOF\n")

          print(f"Generated {len(filters)} filters for {len(matrix_items)} service/environment/stack combinations")
          EOF

      - name: Detect file changes with dynamic path filters
        id: changes
        if: steps.generate-filters.outputs.has_filters == 'true'
        uses: dorny/paths-filter@v3
        with:
          token: ${{ steps.app-token.outputs.token }}
          list-files: shell
          filters: ${{ steps.generate-filters.outputs.filters_yaml }}

      - name: Debug path filter results
        if: steps.generate-filters.outputs.has_filters == 'true'
        run: |
          echo "=== Dynamic Path Filter Debug Information ==="
          echo "Generated filters YAML:"
          echo '${{ steps.generate-filters.outputs.filters_yaml }}'
          echo ""
          echo "Matrix generated:"
          echo '${{ steps.generate-filters.outputs.matrix }}'

      - name: Process changes and manage labels
        id: manage-labels
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            // Load configuration
            const configContent = fs.readFileSync('.github/config/auto-label--mappings.yaml', 'utf8');
            const config = yaml.load(configContent);

            // Parse matrix from previous step
            const matrix = JSON.parse('${{ steps.generate-filters.outputs.matrix }}');

            // Get change detection results
            const hasFilters = '${{ steps.generate-filters.outputs.has_filters }}' === 'true';

            console.log('Matrix items:', matrix.include);
            console.log('Has filters:', hasFilters);

            // Collect required labels based on detected changes
            const requiredLabels = [];            if (hasFilters) {
              // Get all outputs from the changes step
              const changesOutputs = JSON.parse(`${{ toJson(steps.changes.outputs) }}`);

              for (const item of matrix.include) {
                const filterKey = item.filter_key;
                const changeOutput = changesOutputs[filterKey];

                console.log(`Checking filter ${filterKey}: ${changeOutput}`);

                if (changeOutput === 'true') {
                  const label = `deploy:${item.service}:${item.environment}`;
                  if (!requiredLabels.includes(label)) {
                    requiredLabels.push(label);
                  }
                }
              }
            }

            console.log('Required labels:', requiredLabels);

            // Get current PR labels (only deploy: labels)
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number
            });

            const currentDeployLabels = currentLabels
              .map(label => label.name)
              .filter(name => name.startsWith('deploy:'));

            console.log('Current deploy labels:', currentDeployLabels);

            // Create labels if they don't exist
            for (const labelName of requiredLabels) {
              // Find color from environment config
              const parts = labelName.split(':');
              const environment = parts[2];
              const color = config.label_config?.colors?.[environment] || '0052cc';

              try {
                await github.rest.issues.getLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  name: labelName
                });
                console.log(`Label ${labelName} already exists`);
              } catch (error) {
                if (error.status === 404) {
                  console.log(`Creating label: ${labelName} with color: #${color}`);
                  try {
                    await github.rest.issues.createLabel({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      name: labelName,
                      color: color,
                      description: 'Auto-generated deployment label'
                    });
                  } catch (createError) {
                    console.error(`Failed to create label ${labelName}:`, createError.message);
                  }
                }
              }
            }

            // Remove old deploy labels that are no longer needed
            const labelsToRemove = currentDeployLabels.filter(label => !requiredLabels.includes(label));
            for (const label of labelsToRemove) {
              console.log(`Removing label: ${label}`);
              try {
                await github.rest.issues.removeLabel({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  name: label
                });
              } catch (error) {
                console.error(`Failed to remove label ${label}:`, error.message);
              }
            }

            // Add new required labels
            const labelsToAdd = requiredLabels.filter(label => !currentDeployLabels.includes(label));
            for (const label of labelsToAdd) {
              console.log(`Adding label: ${label}`);
              try {
                await github.rest.issues.addLabels({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  labels: [label]
                });
              } catch (error) {
                console.error(`Failed to add label ${label}:`, error.message);
              }
            }

            // Store results for comment step
            core.setOutput('required_labels', JSON.stringify(requiredLabels));
            core.setOutput('labels_added', JSON.stringify(labelsToAdd));
            core.setOutput('labels_removed', JSON.stringify(labelsToRemove));
            core.setOutput('has_changes', requiredLabels.length > 0 ? 'true' : 'false');

            // Generate matrix summary with change information
            const matrixSummary = matrix.include.map(item => {
              const filterKey = item.filter_key;
              const changeOutput = changesOutputs[filterKey];
              return {
                service: item.service,
                environment: item.environment,
                stack: item.stack,
                changed: changeOutput === 'true'
              };
            });
            core.setOutput('matrix_summary', JSON.stringify(matrixSummary));

      - name: Comment on PR with deployment info
        if: steps.manage-labels.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const body = `## ğŸš€ ãƒ‡ãƒ—ãƒ­ã‚¤å¯¾è±¡ã®æ¤œçŸ¥ (Dynamic v2)

            ã“ã®PRã®å¤‰æ›´ã«ã‚ˆã‚Šã€ä»¥ä¸‹ã®ã‚µãƒ¼ãƒ“ã‚¹ãƒ»ç’°å¢ƒãŒãƒ‡ãƒ—ãƒ­ã‚¤å¯¾è±¡ã¨ã—ã¦æ¤œçŸ¥ã•ã‚Œã¾ã—ãŸï¼š

            **æ¤œçŸ¥ã•ã‚ŒãŸãƒ©ãƒ™ãƒ«:**
            ${{ steps.manage-labels.outputs.required_labels }}

            **å¤‰æ›´æ¤œçŸ¥ã®è©³ç´°:**
            ${{ steps.manage-labels.outputs.matrix_summary }}

            ### æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
            - PRã‚’ãƒãƒ¼ã‚¸ã™ã‚‹ã¨ã€å¯¾è±¡ç’°å¢ƒã¸ã®ãƒ‡ãƒ—ãƒ­ã‚¤ãŒè‡ªå‹•å®Ÿè¡Œã•ã‚Œã¾ã™
            - ãƒ©ãƒ™ãƒ«ã‚’æ‰‹å‹•ã§å‰Šé™¤ã™ã‚‹ã“ã¨ã§ã€ç‰¹å®šã®ç’°å¢ƒã®ãƒ‡ãƒ—ãƒ­ã‚¤ã‚’ã‚¹ã‚­ãƒƒãƒ—ã§ãã¾ã™
            - ãƒ©ãƒ™ãƒ«ã‚’æ‰‹å‹•ã§è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€è¿½åŠ ã®ç’°å¢ƒã‚’ãƒ‡ãƒ—ãƒ­ã‚¤å¯¾è±¡ã«å«ã‚ã‚‰ã‚Œã¾ã™

            ### ãƒ©ãƒ™ãƒ«ç®¡ç†ã®å¤‰æ›´
            ${{ steps.manage-labels.outputs.labels_added != '[]' && steps.manage-labels.outputs.labels_added != '' && format('**è¿½åŠ ã•ã‚ŒãŸãƒ©ãƒ™ãƒ«:** {0}', steps.manage-labels.outputs.labels_added) || '' }}
            ${{ steps.manage-labels.outputs.labels_removed != '[]' && steps.manage-labels.outputs.labels_removed != '' && format('**å‰Šé™¤ã•ã‚ŒãŸãƒ©ãƒ™ãƒ«:** {0}', steps.manage-labels.outputs.labels_removed) || '' }}

            ---
            *ã“ã®ã‚³ãƒ¡ãƒ³ãƒˆã¯ Auto Label Dynamic v2 ã«ã‚ˆã‚Šè‡ªå‹•ç”Ÿæˆãƒ»æ›´æ–°ã•ã‚Œã¾ã—ãŸ*`;

            // Check if comment already exists
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.data.find(comment =>
              comment.body.includes('Auto Label Dynamic v2 ã«ã‚ˆã‚Šè‡ªå‹•ç”Ÿæˆãƒ»æ›´æ–°ã•ã‚Œã¾ã—ãŸ')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Add comment when no changes detected
        if: steps.manage-labels.outputs.has_changes == 'false'
        uses: actions/github-script@v7
        with:
          github-token: ${{ steps.app-token.outputs.token }}
          script: |
            const body = `## â„¹ï¸ ãƒ‡ãƒ—ãƒ­ã‚¤å¯¾è±¡ã®æ¤œçŸ¥çµæœ (Dynamic v2)

            ã“ã®PRã®å¤‰æ›´ã§ã¯ã€ãƒ‡ãƒ—ãƒ­ã‚¤å¯¾è±¡ã¨ãªã‚‹ãƒ•ã‚¡ã‚¤ãƒ«ã¯æ¤œçŸ¥ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸã€‚

            **è¨­å®šã‹ã‚‰ç”Ÿæˆã•ã‚ŒãŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼:**
            ${{ steps.generate-filters.outputs.has_filters == 'true' && 'è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å‹•çš„ã«ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãŒç”Ÿæˆã•ã‚Œã¾ã—ãŸ' || 'è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ã‚’ç”Ÿæˆã§ãã¾ã›ã‚“ã§ã—ãŸ' }}

            æ‰‹å‹•ã§ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã§ã€ç‰¹å®šã®ç’°å¢ƒã‚’ãƒ‡ãƒ—ãƒ­ã‚¤å¯¾è±¡ã«å«ã‚ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚

            ---
            *ã“ã®ã‚³ãƒ¡ãƒ³ãƒˆã¯ Auto Label Dynamic v2 ã«ã‚ˆã‚Šè‡ªå‹•ç”Ÿæˆãƒ»æ›´æ–°ã•ã‚Œã¾ã—ãŸ*`;

            // Check if comment already exists
            const comments = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });

            const existingComment = comments.data.find(comment =>
              comment.body.includes('Auto Label Dynamic v2 ã«ã‚ˆã‚Šè‡ªå‹•ç”Ÿæˆãƒ»æ›´æ–°ã•ã‚Œã¾ã—ãŸ')
            );

            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: body
              });
            }

      - name: Summary
        run: |
          echo "=== Dynamic v2 å®Ÿè¡Œçµæœ ==="
          echo "Has filters: ${{ steps.generate-filters.outputs.has_filters }}"
          echo "Required labels: ${{ steps.manage-labels.outputs.required_labels }}"
          echo "Labels added: ${{ steps.manage-labels.outputs.labels_added }}"
          echo "Labels removed: ${{ steps.manage-labels.outputs.labels_removed }}"
          echo "Has changes: ${{ steps.manage-labels.outputs.has_changes }}"
          echo ""

          HAS_CHANGES='${{ steps.manage-labels.outputs.has_changes }}'

          if [ "$HAS_CHANGES" = "false" ]; then
            echo "âœ… å¤‰æ›´æ¤œçŸ¥å®Œäº†: ãƒ‡ãƒ—ãƒ­ã‚¤å¯¾è±¡ãªã—"
            echo "å¤‰æ›´ã•ã‚ŒãŸãƒ•ã‚¡ã‚¤ãƒ«ã«ãƒ‡ãƒ—ãƒ­ã‚¤ãŒå¿…è¦ãªã‚‚ã®ã¯å«ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚"
          else
            echo "âœ… å¤‰æ›´æ¤œçŸ¥å®Œäº†: ãƒ©ãƒ™ãƒ«ä»˜ä¸æ¸ˆã¿"
            echo "æ¤œçŸ¥ã•ã‚ŒãŸãƒ©ãƒ™ãƒ«: ${{ steps.manage-labels.outputs.required_labels }}"
          fi

          echo "Dynamic v2 ã«ã‚ˆã‚‹è‡ªå‹•ãƒ©ãƒ™ãƒ«ä»˜ä¸ãŒå®Œäº†ã—ã¾ã—ãŸã€‚"
