name: 'Wait for Workflows'
description: 'Wait for all workflows to complete and get status'

inputs:
  commit-sha:
    description: 'Commit SHA to check workflows for'
    required: true
  github-token:
    description: 'GitHub token for authentication'
    required: true
  initial-delay:
    description: 'Initial delay in seconds'
    required: false
    default: '30'
  wait-interval:
    description: 'Wait interval in seconds'
    required: false
    default: '20'

outputs:
  workflow-status:
    description: 'Overall workflow status'
    value: ${{ steps.status.outputs.workflow-status }}
  failed-workflows:
    description: 'List of failed workflows'
    value: ${{ steps.status.outputs.failed-workflows }}
  all-workflows:
    description: 'All workflow information'
    value: ${{ steps.status.outputs.all-workflows }}

runs:
  using: 'composite'
  steps:
    - name: Initial delay
      shell: bash
      run: |
        echo "‚è±Ô∏è Waiting for ${{ inputs.initial-delay }} seconds to allow other workflows to start..."
        echo "This helps ensure all related workflows are detected before status checking begins."
        sleep ${{ inputs.initial-delay }}
        echo "‚úÖ Delay completed. Starting workflow status monitoring..."

    - name: Wait for all workflows to complete
      uses: lewagon/wait-on-check-action@v1.4.0
      with:
        ref: ${{ inputs.commit-sha }}
        running-workflow-name: 'wait-for-workflows'
        repo-token: ${{ inputs.github-token }}
        allowed-conclusions: success,failure,skipped,cancelled
        wait-interval: ${{ inputs.wait-interval }}
      continue-on-error: true

    - name: Get workflow status
      id: status
      uses: actions/github-script@v7
      with:
        github-token: ${{ inputs.github-token }}
        script: |
          const commit_sha = context.payload.pull_request.head.sha;

          const { data: workflowRuns } = await github.rest.actions.listWorkflowRunsForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            head_sha: commit_sha,
            per_page: 100
          });

          const relevantRuns = workflowRuns.workflow_runs.filter(
            run => run.name !== 'Wait for Workflows'
          );

          if (relevantRuns.length === 0) {
            core.setOutput('workflow-status', 'no_workflows');
            core.setOutput('failed-workflows', '[]');
            core.setOutput('all-workflows', 'No workflows found for this commit.');
            return;
          }

          const failureCount = relevantRuns.filter(run => run.conclusion === 'failure').length;
          const inProgressCount = relevantRuns.filter(run =>
            run.status === 'in_progress' || run.status === 'queued'
          ).length;

          let overallStatus;
          if (inProgressCount > 0) {
            overallStatus = 'in_progress';
          } else if (failureCount > 0) {
            overallStatus = 'failure';
          } else {
            overallStatus = 'success';
          }

          // Generate workflow table
          let tableRows = ['| Workflow | Status | Result |', '|----------|---------|--------|'];
          const failedWorkflows = [];

          relevantRuns.forEach(run => {
            const statusIcon = run.status === 'completed' ?
              (run.conclusion === 'success' ? '‚úÖ' :
               run.conclusion === 'failure' ? '‚ùå' :
               run.conclusion === 'cancelled' ? '‚èπÔ∏è' :
               run.conclusion === 'skipped' ? '‚è≠Ô∏è' : '‚ùì') :
              'üîÑ';

            const statusText = run.conclusion || run.status;
            const workflowLink = `[${run.name}](${run.html_url})`;
            tableRows.push(`| ${workflowLink} | ${statusIcon} | ${statusText} |`);
            
            if (run.conclusion === 'failure') {
              failedWorkflows.push({
                name: run.name,
                url: run.html_url,
                conclusion: run.conclusion
              });
            }
          });

          core.setOutput('workflow-status', overallStatus);
          core.setOutput('failed-workflows', JSON.stringify(failedWorkflows));
          core.setOutput('all-workflows', tableRows.join('\n'));